
// Email: adhamhamoudy3@gmail.com
// GUI for Coup Game using SFML with random roles and game over handling

#include <SFML/Graphics.hpp>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <random>
#include "Game.hpp"
#include "Governor.hpp"
#include "Spy.hpp"
#include "Baron.hpp"
#include "General.hpp"
#include "Judge.hpp"
#include "Merchant.hpp"

using namespace coup;
using namespace std;

enum class GameState {
    SELECT_PLAYER_COUNT,
    ENTER_PLAYER_NAMES,
    GAME_RUNNING
};

int main() {
    sf::RenderWindow window(sf::VideoMode(1000, 700), "Coup Game - GUI");
    sf::Font font;
    if (!font.loadFromFile("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf")) return -1;

    Game game;
    GameState state = GameState::SELECT_PLAYER_COUNT;

    int playerCount = 0;
    std::vector<std::string> playerNames;
    std::vector<Player*> players;
    std::string inputText = "";
    int currentInputIndex = 0;
    Player* currentPlayer = nullptr;
    std::string errorMessage = "";
    bool awaitingSanctionTarget = false;
    bool awaitingArrestTarget = false;
    bool awaitingCoupTarget = false;
    bool gameOver = false;
    bool awaitingSpyTarget = false;
    bool awaitingUndoTarget = false;
    bool awaitingCancelBribeTarget = false;


    // UI Elements
    sf::Text title("Coup - Strategic Game", font, 36);
    title.setPosition(300, 20);
    title.setFillColor(sf::Color(60, 60, 60));

    sf::RectangleShape inputBox(sf::Vector2f(300, 40));
    inputBox.setPosition(350, 120);
    inputBox.setFillColor(sf::Color(240, 240, 240));
    inputBox.setOutlineColor(sf::Color::Black);
    inputBox.setOutlineThickness(2);

    sf::Text promptText("Enter number of players (2-6):", font, 22);
    promptText.setPosition(350, 80);
    promptText.setFillColor(sf::Color::Black);

    sf::Text inputDisplay("", font, 20);
    inputDisplay.setPosition(360, 125);
    inputDisplay.setFillColor(sf::Color::Black);

    sf::RectangleShape submitBtn(sf::Vector2f(120, 40));
    submitBtn.setPosition(440, 180);
    submitBtn.setFillColor(sf::Color(100, 180, 100));
    sf::Text submitLabel("Submit", font, 20);
    submitLabel.setPosition(465, 185);
    submitLabel.setFillColor(sf::Color::White);

    sf::Text errorText("", font, 18);
    errorText.setPosition(350, 240);
    errorText.setFillColor(sf::Color::Red);

    sf::Text turnText("", font, 24);
    turnText.setPosition(50, 300);
    turnText.setFillColor(sf::Color(40, 40, 40));

    sf::Text coinsText("", font, 20);
    coinsText.setPosition(50, 340);
    coinsText.setFillColor(sf::Color(80, 80, 80));

    sf::RectangleShape gatherBtn(sf::Vector2f(120, 50));
    gatherBtn.setPosition(50, 400);
    gatherBtn.setFillColor(sf::Color(0, 200, 100));
    sf::Text gatherText("Gather", font, 20);
    gatherText.setPosition(70, 412);
    gatherText.setFillColor(sf::Color::White);

    sf::RectangleShape taxBtn(sf::Vector2f(120, 50));
    taxBtn.setPosition(200, 400);
    taxBtn.setFillColor(sf::Color(0, 100, 220));
    sf::Text taxText("Tax", font, 20);
    taxText.setPosition(240, 412);
    taxText.setFillColor(sf::Color::White);

    sf::RectangleShape bribeBtn(sf::Vector2f(120, 50));
    bribeBtn.setPosition(350, 400);
    bribeBtn.setFillColor(sf::Color(150, 80, 200));
    sf::Text bribeText("Bribe", font, 20);
    bribeText.setPosition(385, 412);
    bribeText.setFillColor(sf::Color::White);

    sf::RectangleShape arrestBtn(sf::Vector2f(120, 50));
    arrestBtn.setPosition(500, 400);
    arrestBtn.setFillColor(sf::Color(220, 80, 80));
    sf::Text arrestText("Arrest", font, 20);
    arrestText.setPosition(530, 412);
    arrestText.setFillColor(sf::Color::White);

    sf::RectangleShape coupBtn(sf::Vector2f(120, 50));
    coupBtn.setPosition(650, 400);
    coupBtn.setFillColor(sf::Color(255, 140, 0));
    sf::Text coupText("Coup", font, 20);
    coupText.setPosition(690, 412);
    coupText.setFillColor(sf::Color::White);
    sf::RectangleShape sanctionBtn(sf::Vector2f(120, 50));
    sanctionBtn.setPosition(800, 400);
    sanctionBtn.setFillColor(sf::Color(200, 150, 50));

    sf::Text sanctionText("Sanction", font, 18);
    sanctionText.setPosition(815, 412);
    sanctionText.setFillColor(sf::Color::White);
    sf::RectangleShape spyBtn(sf::Vector2f(120, 40));
spyBtn.setPosition(50, 470);
spyBtn.setFillColor(sf::Color(100, 150, 250));
sf::Text spyText("Spy", font, 18);
spyText.setPosition(90, 475);
spyText.setFillColor(sf::Color::White);

sf::RectangleShape investBtn(sf::Vector2f(120, 40));
investBtn.setPosition(200, 470);
investBtn.setFillColor(sf::Color(100, 200, 150));
sf::Text investText("Invest", font, 18);
investText.setPosition(230, 475);
investText.setFillColor(sf::Color::White);

sf::RectangleShape undoBtn(sf::Vector2f(120, 40));
undoBtn.setPosition(350, 470);
undoBtn.setFillColor(sf::Color(200, 180, 100));
sf::Text undoText("Undo", font, 18);
undoText.setPosition(385, 475);
undoText.setFillColor(sf::Color::White);

sf::RectangleShape cancelBribeBtn(sf::Vector2f(120, 40));
cancelBribeBtn.setPosition(500, 470);
cancelBribeBtn.setFillColor(sf::Color(180, 100, 150));
sf::Text cancelBribeText("Cancel Bribe", font, 15);
cancelBribeText.setPosition(505, 475);
cancelBribeText.setFillColor(sf::Color::White);


    std::vector<sf::Text> playerButtons;

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::TextEntered && event.text.unicode < 128) {
                char c = static_cast<char>(event.text.unicode);
                if (c == '\b') {
                    if (!inputText.empty()) inputText.pop_back();
                } else if (isalnum(c) || c == ' ') {
                    inputText += c;
                }
            }

            if (event.type == sf::Event::MouseButtonPressed) {
                if (gameOver) continue;
                sf::Vector2f mouse(event.mouseButton.x, event.mouseButton.y);
                if (submitBtn.getGlobalBounds().contains(mouse)) {
                    if (state == GameState::SELECT_PLAYER_COUNT) {
                        try {
                            playerCount = std::stoi(inputText);
                            if (playerCount < 2 || playerCount > 6) throw std::runtime_error("Invalid range");
                            playerNames.resize(playerCount);
                            inputText.clear();
                            promptText.setString("Enter name for Player 1:");
                            state = GameState::ENTER_PLAYER_NAMES;
                        } catch (...) {
                            errorMessage = "Please enter a number between 2 and 6.";
                        }
                    } else if (state == GameState::ENTER_PLAYER_NAMES) {
                        if (!inputText.empty()) {
                            playerNames[currentInputIndex++] = inputText;
                            inputText.clear();
                            if (currentInputIndex < playerCount) {
                                promptText.setString("Enter name for Player " + to_string(currentInputIndex + 1) + ":");
                            } else {
                                std::random_device rd;
                                std::mt19937 gen(rd());
                                std::uniform_int_distribution<> dist(0, 5);

                                for (const std::string& name : playerNames) {
                                    int role = dist(gen);
                                    Player* p = nullptr;
                                    switch (role) {
                                        case 0: p = new Governor(game, name); break;
                                        case 1: p = new Spy(game, name); break;
                                        case 2: p = new Baron(game, name); break;
                                        case 3: p = new General(game, name); break;
                                        case 4: p = new Judge(game, name); break;
                                        case 5: p = new Merchant(game, name); break;
                                    }
                                    players.push_back(p);
                                }
                                currentPlayer = players[0];
                                state = GameState::GAME_RUNNING;
                            }
                        } else {
                            errorMessage = "Name cannot be empty.";
                        }
                    }
                }

                if (state == GameState::GAME_RUNNING && !gameOver && !awaitingArrestTarget && !awaitingCoupTarget) {
                   if (sanctionBtn.getGlobalBounds().contains(mouse)) {
    awaitingSanctionTarget = true;
    errorMessage = "Select a player to sanction.";
}

                    if (gatherBtn.getGlobalBounds().contains(mouse)) {
    try {
        currentPlayer->gather();
        errorMessage = "";
        game.advance_turn();
        currentPlayer = nullptr;
    } catch (const std::exception& e) {
        errorMessage = e.what();
    }
}
if (taxBtn.getGlobalBounds().contains(mouse)) {
    try {
        currentPlayer->tax();
        errorMessage = "";
        game.advance_turn();
        currentPlayer = nullptr;
    } catch (const std::exception& e) {
        errorMessage = e.what();
    }
}
if (bribeBtn.getGlobalBounds().contains(mouse)) {
    try {
        currentPlayer->bribe();
        errorMessage = "";
        // לא advance_turn – כי מותר עוד פעולה בתור!
    } catch (const std::exception& e) {
        errorMessage = e.what();
    }
}

                } else if ((awaitingArrestTarget || awaitingCoupTarget || awaitingSanctionTarget) && !gameOver) {
    for (size_t i = 0; i < playerButtons.size(); ++i) {
        if (playerButtons[i].getGlobalBounds().contains(mouse)) {
            try {
                if (awaitingArrestTarget) {
                    currentPlayer->arrest(*players[i]);
                    awaitingArrestTarget = false;
                } else if (awaitingCoupTarget) {
                    game.coup(currentPlayer, players[i]);
                    awaitingCoupTarget = false;
                } else if (awaitingSanctionTarget) {
                    currentPlayer->sanction(*players[i]);
                    awaitingSanctionTarget = false;
                }

                errorMessage = "";
                game.advance_turn();
                currentPlayer = nullptr;

            } catch (const std::exception& e) {
                errorMessage = e.what();
                awaitingArrestTarget = false;
                awaitingCoupTarget = false;
                awaitingSanctionTarget = false;
            }
            break;
        }
    }
}

            }
        }

        inputDisplay.setString(inputText);
        errorText.setString(errorMessage);

        window.clear(sf::Color(245, 245, 245));
        window.draw(title);

        if (state != GameState::GAME_RUNNING) {
            window.draw(promptText);
            window.draw(inputBox);
            window.draw(inputDisplay);
            window.draw(submitBtn);
            window.draw(submitLabel);
            if (!errorMessage.empty()) window.draw(errorText);
        } else {
            if (!gameOver && game.players().size() > 1) {
                turnText.setString("Turn: " + game.turn());
            } else if (!gameOver && game.players().size() == 1) {
                turnText.setString("Game Over");
                gameOver = true;
            } else {
                turnText.setString("Game Over");
            }

            if (!gameOver) {
                for (Player* p : players) {
                    if (p->name() == game.turn()) {
                        currentPlayer = p;
                        break;
                    }
                }
            }

            coinsText.setString("Coins: " + (gameOver || currentPlayer == nullptr ? "-" : std::to_string(currentPlayer->coins())));

            window.draw(turnText);
            window.draw(coinsText);
            window.draw(gatherBtn);
            window.draw(gatherText);
            window.draw(taxBtn);
            window.draw(taxText);
            window.draw(bribeBtn);
            window.draw(bribeText);
            window.draw(arrestBtn);
            window.draw(arrestText);
            window.draw(coupBtn);
            window.draw(coupText);
            window.draw(sanctionBtn);
            window.draw(sanctionText);

            if (currentPlayer->role() == "Spy") {
    window.draw(spyBtn);
    window.draw(spyText);
}
if (currentPlayer->role() == "Baron") {
    window.draw(investBtn);
    window.draw(investText);
}
if (currentPlayer->role() == "Governor") {
    window.draw(undoBtn);
    window.draw(undoText);
}
if (currentPlayer->role() == "Judge") {
    window.draw(cancelBribeBtn);
    window.draw(cancelBribeText);
}

            playerButtons.clear();
            int y = 480;
            for (size_t i = 0; i < players.size(); ++i) {
                if (!players[i]->active()) continue;
                sf::Text pText(players[i]->name() + " [" + players[i]->role() + "] (" + to_string(players[i]->coins()) + ")", font, 18);
                pText.setPosition(50, y);
                pText.setFillColor(sf::Color::Black);
                playerButtons.push_back(pText);
                window.draw(pText);
                y += 30;
            }

            if (!errorMessage.empty()) window.draw(errorText);

            if (gameOver && game.players().size() == 1) {
                sf::Text winText("Winner: " + game.winner(), font, 30);
                winText.setPosition(300, 600);
                winText.setFillColor(sf::Color(0, 120, 255));
                window.draw(winText);
            }
        }

        window.display();
    }

    return 0;
}